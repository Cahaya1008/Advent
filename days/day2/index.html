<script>
  // ===== CONFIG =====
  const DAY_LETTER_KEY = "advent_day_2_letter";
  const HIDDEN_LETTER = "H";
  const FINAL_SENTENCE = "Cross my heart, hope to die";
  // new rhyme target: "stick a needle in my eye"
  const OATH_TARGET = "stick a needle in my eye";

  // ===== STATE =====
  let rootNodes = [];
  let allBracketNodes = [];
  let finalPhase = false;
  let oathUnlocked = false;

  const puzzleTextEl = document.getElementById("puzzleText");
  const answerInput = document.getElementById("answerInput");
  const submitAnswerBtn = document.getElementById("submitAnswer");
  const statusLineEl = document.getElementById("statusLine");
  const alreadyBanner = document.getElementById("alreadyBanner");

  // ===== BASIC NODE HELPERS =====
  let nextId = 1;
  function textNode(text) {
    return { type: "text", text };
  }

  function bracketNode(answer, children) {
    const node = {
      type: "bracket",
      id: nextId++,
      answer: answer.toString(),              // display form
      answerNormalized: normalizeAnswer(answer.toString()),
      children,
      solved: false
    };
    allBracketNodes.push(node);
    return node;
  }

  function normalizeAnswer(str) {
    return str.trim().toLowerCase();
  }

  // ===== BUILD THE NUCLEAR PUZZLE (ALL NEW CHAINS) =====
  function buildPuzzle() {
    allBracketNodes = [];
    nextId = 1;

    // ----- CROSS CHAIN -----
    const nodePAIN = bracketNode("pain", [
      textNode("sensation you feel if you slice your finger with a very sharp palette knife")
    ]);

    const nodeBOB = bracketNode("Bob", [
      textNode("first name of the soft-spoken TV painter with big hair who talks about happy little accidents")
    ]);

    const nodeROSS = bracketNode("Ross", [
      textNode("surname of painter "),
      nodeBOB,
      textNode(" who teaches turning "),
      nodePAIN,
      textNode(" into mountains and trees")
    ]);

    const nodeCROSS = bracketNode("Cross", [
      textNode("word you get by putting the letter C in front of "),
      nodeROSS
    ]);

    // ----- MY CHAIN -----
    const nodeME = bracketNode("me", [
      textNode("object-form pronoun you use to talk about yourself (\"they gave it to ___\")")
    ]);

    const nodeMINE = bracketNode("mine", [
      textNode("possessive word meaning \"belonging to\" based on "),
      nodeME
    ]);

    const nodeMY = bracketNode("my", [
      textNode("short possessive determiner that goes before nouns (\"___ sketchbook\"), paired with "),
      nodeMINE,
      textNode(" when the noun is left off")
    ]);

    // ----- HEART CHAIN -----
    const nodeVALVE = bracketNode("valve", [
      textNode("structure inside the heart that opens and closes so blood flows in only one direction")
    ]);

    const nodeAORTA = bracketNode("aorta", [
      textNode("largest artery leaving the left ventricle of the human heart")
    ]);

    const nodeORGAN = bracketNode("organ", [
      textNode("type of body part that the liver and lungs are; the heart is also this")
    ]);

    const nodeHEART = bracketNode("heart", [
      textNode("four-chambered "),
      nodeORGAN,
      textNode(" that pumps blood through the "),
      nodeAORTA,
      textNode(" and relies on at least one "),
      nodeVALVE
    ]);

    // ----- HOPE CHAIN -----
    const nodeDESPAIR = bracketNode("despair", [
      textNode("emotion that is basically the opposite of hope")
    ]);

    const nodeSTAR = bracketNode("star", [
      textNode("celestial object you \"wish upon\" in the classic Disney song from \"Pinocchio\"")
    ]);

    const nodeHOPE = bracketNode("hope", [
      textNode("feeling you have when you look up at a shooting "),
      nodeSTAR,
      textNode(" instead of sinking into "),
      nodeDESPAIR
    ]);

    // ----- TO CHAIN -----
    const nodeTWO = bracketNode("two", [
      textNode("number of shoes in a typical pair of sneakers")
    ]);

    const nodeTOO = bracketNode("too", [
      textNode("word that sounds like "),
      nodeTWO,
      textNode(" and means \"also\"")
    ]);

    const nodeTO = bracketNode("to", [
      textNode("short preposition that is a homophone of both "),
      nodeTWO,
      textNode(" and "),
      nodeTOO
    ]);

    // ----- DIE CHAIN (fantasy / TTRPG, one-word answers) -----
    const nodeHOARD = bracketNode("hoard", [
      textNode("word for a hidden stash of treasure a storybook dragon might sleep on")
    ]);

    const nodeSMAUG = bracketNode("Smaug", [
      textNode("dragon who guards a gold "),
      nodeHOARD,
      textNode(" in a novel about Bilbo Baggins")
    ]);

    const nodeHOBBIT = bracketNode("hobbit", [
      textNode("name of the small fantasy race Bilbo Baggins belongs to")
    ]);

    const nodeFANTASY = bracketNode("fantasy", [
      textNode("genre of fiction that usually includes at least one "),
      nodeHOBBIT,
      textNode(" and sometimes a dragon like "),
      nodeSMAUG
    ]);

    const nodeDRAGON = bracketNode("dragon", [
      textNode("fire-breathing creature common in "),
      nodeFANTASY
    ]);

    const nodeDND = bracketNode("DND", [
      textNode("three-letter abbreviation for the tabletop role-playing game where you roll polyhedral dice to battle a "),
      nodeDRAGON
    ]);

    const nodeDIE = bracketNode("die", [
      textNode("singular word for one of the polyhedral objects you roll in "),
      nodeDND,
      textNode(" (as in \"roll one d20 ___\")")
    ]);

    // ----- ROOT SENTENCE -----
    rootNodes = [
      nodeCROSS,
      textNode(" "),
      nodeMY,
      textNode(" "),
      nodeHEART,
      textNode(", "),
      nodeHOPE,
      textNode(" "),
      nodeTO,
      textNode(" "),
      nodeDIE
    ];
  }

  // ===== RENDERING =====
  function getInnermostUnsolvedIds() {
    const innermost = new Set();

    function dfs(node) {
      if (node.type !== "bracket" || node.solved) {
        if (node.children) node.children.forEach(dfs);
        return;
      }

      let hasUnsolvedChild = false;
      if (node.children) {
        for (const child of node.children) {
          if (child.type === "bracket" && !child.solved) {
            hasUnsolvedChild = true;
            dfs(child);
          } else if (child.children) {
            dfs(child);
          }
        }
      }
      if (!hasUnsolvedChild) {
        innermost.add(node.id);
      }
    }

    rootNodes.forEach(dfs);
    return innermost;
  }

  function renderPuzzle() {
    if (finalPhase) return;

    const innermost = getInnermostUnsolvedIds();

    function renderNode(node) {
      if (node.type === "text") {
        return document.createTextNode(node.text);
      }

      if (node.solved) {
        return document.createTextNode(node.answer);
      }

      const isInner = innermost.has(node.id);
      const wrapper = document.createElement("span");

      if (isInner) {
        wrapper.className = "bracket-innermost";
        const innerSpan = document.createElement("span");
        innerSpan.className = "bracket-innermost-inner";

        innerSpan.appendChild(document.createTextNode("["));
        node.children.forEach((child) => innerSpan.appendChild(renderNode(child)));
        innerSpan.appendChild(document.createTextNode("]"));

        wrapper.appendChild(innerSpan);
      } else {
        wrapper.appendChild(document.createTextNode("["));
        node.children.forEach((child) => wrapper.appendChild(renderNode(child)));
        wrapper.appendChild(document.createTextNode("]"));
      }

      return wrapper;
    }

    puzzleTextEl.innerHTML = "";
    rootNodes.forEach((n) => puzzleTextEl.appendChild(renderNode(n)));

    const remaining = allBracketNodes.filter((n) => !n.solved).length;
    if (remaining > 0) {
      setStatus(`Brackets remaining: ${remaining}`, "muted");
    } else {
      showFinalSentence();
    }
  }

  // ===== STATUS =====
  function setStatus(msg, tone) {
    statusLineEl.textContent = msg;
    statusLineEl.className = "";
    if (tone) statusLineEl.classList.add(tone);
  }

  // ===== FINAL SENTENCE PHASE =====
  function showFinalSentence() {
    finalPhase = true;
    const container = document.createElement("span");

    const parts = [
      { text: "Cross", isWord: true },
      { text: " ", isWord: false },
      { text: "my", isWord: true },
      { text: " ", isWord: false },
      { text: "heart", isWord: true },
      { text: ",", isWord: false },
      { text: " ", isWord: false },
      { text: "hope", isWord: true },
      { text: " ", isWord: false },
      { text: "to", isWord: true },
      { text: " ", isWord: false },
      { text: "die", isWord: true }
    ];

    parts.forEach((part, idx) => {
      if (!part.isWord) {
        container.appendChild(document.createTextNode(part.text));
      } else {
        const span = document.createElement("span");
        span.className = "final-word";
        span.dataset.index = String(idx);
        span.textContent = part.text;
        container.appendChild(span);
      }
    });

    puzzleTextEl.innerHTML = "";
    puzzleTextEl.appendChild(container);

    document.getElementById("inputLabel").textContent =
      "Finish the rhyme that begins with “stick…”";
    answerInput.value = "";
    answerInput.placeholder = "Finish the rhyme that begins with “stick…”";
    setStatus(
      "All brackets solved! Now finish the childhood promise to unlock the letter.",
      "good"
    );
  }

  function attachFinalWordClicks() {
    const wordEls = document.querySelectorAll(".final-word");
    wordEls.forEach((el) => {
      if (oathUnlocked) {
        el.classList.add("secret-ready");
      }
      el.addEventListener("click", () => {
        const word = el.textContent || "";
        handleFinalWordClick(word);
      });
    });
  }

  function handleFinalWordClick(word) {
    if (!oathUnlocked) {
      setStatus(
        "Make the needle promise first, then click the word after “my”.",
        "bad"
      );
      return;
    }

    const normalizedWord = word.toLowerCase();
    if (normalizedWord !== "heart") {
      setStatus("That’s not the word immediately after “my”. Try again.", "bad");
      return;
    }

    if (localStorage.getItem(DAY_LETTER_KEY)) {
      openModal("letterModal");
      return;
    }

    localStorage.setItem(DAY_LETTER_KEY, HIDDEN_LETTER);
    alreadyBanner.style.display = "block";
    openModal("letterModal");
  }

  // ===== INPUT HANDLING =====
  function handleSubmit() {
    const raw = answerInput.value.trim();
    if (!raw) return;

    if (!finalPhase) {
      handleBracketAnswer(raw);
    } else {
      handleOathInput(raw);
    }
    answerInput.value = "";
  }

  function handleBracketAnswer(raw) {
    const guess = normalizeAnswer(raw);
    if (!guess) return;

    const target = allBracketNodes.find(
      (n) => !n.solved && n.answerNormalized === guess
    );

    if (!target) {
      setStatus("No unsolved bracket is expecting that answer.", "bad");
      return;
    }

    target.solved = true;
    setStatus(`Solved a bracket: ${target.answer}`, "good");
    renderPuzzle();
  }

  function normalizeOath(str) {
    return str
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, " ")
      .trim();
  }

  function handleOathInput(raw) {
    const norm = normalizeOath(raw);
    if (norm === OATH_TARGET) {
      if (!oathUnlocked) {
        oathUnlocked = true;
        setStatus(
          "Promise accepted. Now click the word that comes immediately after “my”.",
          "good"
        );
        attachFinalWordClicks();
      } else {
        setStatus(
          "You’ve already unlocked the letter. Click the word after “my”.",
          "muted"
        );
      }
    } else {
      setStatus(
        "That doesn’t quite match the rhyme. Think schoolyard version.",
        "bad"
      );
    }
  }

  // ===== MODALS + NAV =====
  function openModal(id) {
    const modal = document.getElementById(id);
    if (!modal) return;
    modal.classList.add("open");
    modal.setAttribute("aria-hidden", "false");
  }

  function closeModal(id) {
    const modal = document.getElementById(id);
    if (!modal) return;
    modal.classList.remove("open");
    modal.setAttribute("aria-hidden", "true");
  }

  // ===== INIT =====
  function init() {
    if (localStorage.getItem(DAY_LETTER_KEY)) {
      alreadyBanner.style.display = "block";
    }

    buildPuzzle();
    renderPuzzle();

    submitAnswerBtn.addEventListener("click", handleSubmit);
    answerInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") handleSubmit();
    });

    document.getElementById("backButton").addEventListener("click", () => {
      window.location.href = "../../index.html";
    });

    document
      .getElementById("goHomeFromModal")
      .addEventListener("click", () => {
        window.location.href = "../../index.html";
      });

    document
      .querySelectorAll("[data-close]")
      .forEach((btn) =>
        btn.addEventListener("click", () =>
          closeModal(btn.getAttribute("data-close"))
        )
      );

    document.querySelectorAll(".modal").forEach((modal) => {
      modal.addEventListener("click", (e) => {
        if (e.target === modal) {
          modal.classList.remove("open");
          modal.setAttribute("aria-hidden", "true");
        }
      });
    });

    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape") {
        document
          .querySelectorAll(".modal.open")
          .forEach((m) => m.classList.remove("open"));
      }
    });

    const observer = new MutationObserver(() => {
      if (finalPhase) attachFinalWordClicks();
    });
    observer.observe(puzzleTextEl, { childList: true, subtree: true });

    setStatus(
      "Solve any innermost blue bracket to start collapsing the madness.",
      "muted"
    );
  }

  init();
</script>
