<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Day 2 – Bracket City</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap" rel="stylesheet" />
  <style>
    :root {
      --bg: #111827;
      --bg-soft: #fdf6ed;
      --accent: #7b2333;
      --accent-soft: #f4e4d8;
      --text-main: #111827;
      --muted: #6b7280;
      --good: #15803d;
      --bad: #b91c1c;
      --bracket-bg: #dbeafe;
      --bracket-border: #93c5fd;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: "Poppins", system-ui, -apple-system, BlinkMacSystemFont,
        "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #020617 0, #111827 40%, #020617 100%);
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 1.5rem 0.75rem;
      color: var(--text-main);
    }

    .page {
      max-width: 900px;
      width: 100%;
      background: var(--bg-soft);
      border-radius: 22px;
      box-shadow: 0 16px 40px rgba(0, 0, 0, 0.55);
      padding: 1.6rem 1.6rem 1.3rem;
      position: relative;
    }

    header {
      text-align: center;
      margin-bottom: 1rem;
    }

    header h1 {
      font-size: 2rem;
      color: var(--accent);
      margin-bottom: 0.2rem;
    }

    header p {
      font-size: 0.9rem;
      color: var(--muted);
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      font-size: 0.8rem;
      background: var(--accent-soft);
      padding: 0.22rem 0.6rem;
      border-radius: 999px;
      margin-bottom: 0.3rem;
      color: #5a2b2b;
    }

    .already-banner {
      position: absolute;
      top: 0.75rem;
      right: 1rem;
      font-size: 0.75rem;
      background: #ecfdf5;
      border-radius: 999px;
      padding: 0.2rem 0.6rem;
      border: 1px solid #bbf7d0;
      color: #166534;
      display: none;
    }

    main {
      margin-top: 0.3rem;
    }

    #puzzleContainer {
      border-radius: 14px;
      padding: 0.9rem 1rem;
      background: #fff;
      box-shadow: inset 0 0 0 1px rgba(15, 23, 42, 0.06);
      font-size: 1rem;
      line-height: 1.6;
    }

    .bracket-innermost {
      background: var(--bracket-bg);
      border-radius: 8px;
      border: 1px dashed var(--bracket-border);
      padding: 0.1rem 0.15rem;
      margin: 0 0.05rem;
    }

    .bracket-innermost-inner {
      font-weight: 600;
    }

    .controls {
      margin-top: 0.75rem;
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
    }

    .controls label {
      font-size: 0.9rem;
    }

    .input-row {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    #answerInput {
      flex: 1;
      min-width: 180px;
      padding: 0.5rem 0.7rem;
      border-radius: 999px;
      border: 1px solid #d1c2b4;
      font-size: 0.95rem;
    }

    #answerInput:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 1px;
    }

    .btn {
      border-radius: 999px;
      border: none;
      padding: 0.48rem 1.1rem;
      font-size: 0.9rem;
      font-weight: 500;
      cursor: pointer;
      background: var(--accent);
      color: #fff;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.25rem;
      white-space: nowrap;
      transition: transform 0.1s ease, box-shadow 0.12s ease;
    }

    .btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.25);
    }

    .btn-secondary {
      background: #f1e4d4;
      color: #5a4032;
      border: 1px solid #d5c4b0;
    }

    .btn-secondary:hover {
      box-shadow: 0 3px 8px rgba(0, 0, 0, 0.2);
    }

    #statusLine {
      font-size: 0.85rem;
      min-height: 1.2rem;
    }

    #statusLine.good {
      color: var(--good);
    }

    #statusLine.bad {
      color: var(--bad);
    }

    #statusLine.muted {
      color: var(--muted);
    }

    #hintBox {
      margin-top: 0.6rem;
      padding: 0.55rem 0.75rem;
      background: #f8ecdc;
      border-radius: 10px;
      border: 1px dashed #d1b491;
      font-size: 0.85rem;
    }

    #hintBox strong {
      font-weight: 600;
    }

    footer {
      margin-top: 1rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.6rem;
      flex-wrap: wrap;
      font-size: 0.8rem;
    }

    .final-word {
      cursor: pointer;
      border-radius: 6px;
      padding: 0 0.1rem;
      transition: background 0.12s ease, box-shadow 0.12s ease;
    }

    .final-word:hover {
      background: #fee2e2;
      box-shadow: 0 0 0 1px #fecaca;
    }

    .final-word.secret-ready {
      box-shadow: 0 0 0 2px rgba(34, 197, 94, 0.7);
    }

    /* Modal */

    .modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.55);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 1rem;
      z-index: 40;
    }

    .modal.open {
      display: flex;
    }

    .modal-content {
      max-width: 420px;
      width: 100%;
      padding: 1.2rem 1.3rem 1.05rem;
      background: #faf5f0;
      border-radius: 18px;
      color: #333;
      position: relative;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
    }

    .modal h2 {
      font-size: 1.1rem;
      margin-bottom: 0.35rem;
    }

    .modal p {
      font-size: 0.9rem;
      line-height: 1.45;
    }

    .modal-close {
      position: absolute;
      right: 0.7rem;
      top: 0.6rem;
      border: none;
      background: transparent;
      font-size: 1.2rem;
      cursor: pointer;
      color: #555;
    }

    .modal-footer {
      margin-top: 0.9rem;
      display: flex;
      justify-content: flex-end;
      gap: 0.5rem;
      flex-wrap: wrap;
    }
  </style>
</head>
<body>
  <div class="page">
    <div class="already-banner" id="alreadyBanner">
      Letter already collected ✅
    </div>

    <header>
      <div class="badge">
        <span>Day 2</span> <span>Bracket City</span>
      </div>
      <h1>Day 2 – Bracket City</h1>
      <p>Type the answer to any blue bracket and hit Enter. You can solve them in any order.</p>
    </header>

    <main>
      <section id="puzzleContainer">
        <div id="puzzleText"></div>
      </section>

      <section class="controls">
        <label for="answerInput" id="inputLabel">Type an answer for any blue bracket…</label>
        <div class="input-row">
          <input id="answerInput" autocomplete="off" />
          <button class="btn" id="submitAnswer">Submit</button>
        </div>
        <p id="statusLine" class="muted"></p>
      </section>

      <section id="hintBox">
        <p><strong>Letter hint:</strong> In the final sentence, click the word that comes immediately after “my”. The secret letter is the <strong>first letter</strong> of that word.</p>
        <p id="oathHint" style="margin-top:0.35rem;">
          After all the brackets disappear, finish the childhood rhyme that follows “hope to die.” Type the part that begins with <em>“stick…”</em>
        </p>
      </section>
    </main>

    <footer>
      <button class="btn btn-secondary" id="backButton">← Back to calendar</button>
      <span>Each day hides at most one letter.</span>
    </footer>
  </div>

  <!-- Letter collected modal -->
  <div class="modal" id="letterModal" aria-hidden="true">
    <div class="modal-content">
      <button class="modal-close" data-close="letterModal">&times;</button>
      <h2>Letter collected ✉️</h2>
      <p>
        Needle promise made. This letter has been stored in your collection on the main calendar page.
      </p>
      <div class="modal-footer">
        <button class="btn btn-secondary" data-close="letterModal">
          Stay on this page
        </button>
        <button class="btn" id="goHomeFromModal">
          Back to calendar
        </button>
      </div>
    </div>
  </div>

  <script>
    // ===== CONFIG =====
    const DAY_LETTER_KEY = "advent_day_2_letter";
    const HIDDEN_LETTER = "H";
    const OATH_TARGET = "stick a needle in my eye";

    // ===== STATE =====
    let rootNodes = [];
    let allBracketNodes = [];
    let finalPhase = false;
    let oathUnlocked = false;

    const puzzleTextEl = document.getElementById("puzzleText");
    const answerInput = document.getElementById("answerInput");
    const submitAnswerBtn = document.getElementById("submitAnswer");
    const statusLineEl = document.getElementById("statusLine");
    const alreadyBanner = document.getElementById("alreadyBanner");

    // ===== NODE HELPERS =====
    let nextId = 1;
    function textNode(text) {
      return { type: "text", text };
    }

    function normalizeAnswer(str) {
      return str.trim().toLowerCase();
    }

    function bracketNode(answer, children) {
      const node = {
        type: "bracket",
        id: nextId++,
        answer: answer.toString(),
        answerNormalized: normalizeAnswer(answer.toString()),
        children,
        solved: false
      };
      allBracketNodes.push(node);
      return node;
    }

    // ===== BUILD PUZZLE =====
    function buildPuzzle() {
      allBracketNodes = [];
      nextId = 1;

      // CROSS chain (art)
      const nodePAIN = bracketNode("pain", [
        textNode("sensation you feel if you slice your finger with a very sharp palette knife")
      ]);

      const nodeBOB = bracketNode("Bob", [
        textNode("first name of the soft-spoken TV painter with big hair who talks about happy little accidents")
      ]);

      const nodeROSS = bracketNode("Ross", [
        textNode("surname of painter "),
        nodeBOB,
        textNode(" who teaches turning "),
        nodePAIN,
        textNode(" into mountains and trees")
      ]);

      const nodeCROSS = bracketNode("Cross", [
        textNode("word you get by putting the letter C in front of "),
        nodeROSS
      ]);

      // MY chain (pronouns)
      const nodeME = bracketNode("me", [
        textNode("object-form pronoun you use to talk about yourself (\"they gave it to ___\")")
      ]);

      const nodeMINE = bracketNode("mine", [
        textNode("possessive word meaning \"belonging to\" based on "),
        nodeME
      ]);

      const nodeMY = bracketNode("my", [
        textNode("short possessive determiner that goes before nouns (\"___ sketchbook\"), paired with "),
        nodeMINE,
        textNode(" when the noun is left off")
      ]);

      // HEART chain (biology)
      const nodeORGAN = bracketNode("organ", [
        textNode("type of body part that the liver and lungs are; the heart is also this")
      ]);

      const nodeAORTA = bracketNode("aorta", [
        textNode("largest artery leaving the left ventricle of the human heart")
      ]);

      const nodeVALVE = bracketNode("valve", [
        textNode("structure inside the heart that opens and closes so blood flows in only one direction")
      ]);

      const nodeHEART = bracketNode("heart", [
        textNode("four-chambered "),
        nodeORGAN,
        textNode(" that pumps blood through the "),
        nodeAORTA,
        textNode(" and relies on at least one "),
        nodeVALVE
      ]);

      // HOPE chain (emotion / Disney)
      const nodeDESPAIR = bracketNode("despair", [
        textNode("emotion that is basically the opposite of hope")
      ]);

      const nodeSTAR = bracketNode("star", [
        textNode("celestial object you are told to wish upon in a famous Disney song")
      ]);

      const nodeHOPE = bracketNode("hope", [
        textNode("feeling you have when you look up at a shooting "),
        nodeSTAR,
        textNode(" instead of sinking into "),
        nodeDESPAIR
      ]);

      // TO chain (homophones)
      const nodeTWO = bracketNode("two", [
        textNode("number of shoes in a typical pair of sneakers")
      ]);

      const nodeTOO = bracketNode("too", [
        textNode("word that sounds like "),
        nodeTWO,
        textNode(" and means \"also\"")
      ]);

      const nodeTO = bracketNode("to", [
        textNode("short preposition that is a homophone of both "),
        nodeTWO,
        textNode(" and "),
        nodeTOO
      ]);

      // DIE chain (fantasy / TTRPG)
      const nodeHOARD = bracketNode("hoard", [
        textNode("word for a hidden stash of treasure a storybook dragon might sleep on")
      ]);

      const nodeSMAUG = bracketNode("Smaug", [
        textNode("dragon who guards a gold "),
        nodeHOARD,
        textNode(" in a novel about Bilbo Baggins")
      ]);

      const nodeHOBBIT = bracketNode("hobbit", [
        textNode("name of the small fantasy race Bilbo Baggins belongs to")
      ]);

      const nodeFANTASY = bracketNode("fantasy", [
        textNode("genre of fiction that usually includes at least one "),
        nodeHOBBIT,
        textNode(" and sometimes a dragon like "),
        nodeSMAUG
      ]);

      const nodeDRAGON = bracketNode("dragon", [
        textNode("fire-breathing creature common in "),
        nodeFANTASY
      ]);

      const nodeDND = bracketNode("DND", [
        textNode("three-letter abbreviation for the tabletop role-playing game where you roll polyhedral dice to battle a "),
        nodeDRAGON
      ]);

      const nodeDIE = bracketNode("die", [
        textNode("singular word for one of the polyhedral objects you roll in "),
        nodeDND,
        textNode(" (as in \"roll one d20 ___\")")
      ]);

      // Root sentence
      rootNodes = [
        nodeCROSS,
        textNode(" "),
        nodeMY,
        textNode(" "),
        nodeHEART,
        textNode(", "),
        nodeHOPE,
        textNode(" "),
        nodeTO,
        textNode(" "),
        nodeDIE
      ];
    }

    // ===== RENDERING =====
    function getInnermostUnsolvedIds() {
      const innermost = new Set();

      function dfs(node) {
        if (node.type !== "bracket" || node.solved) {
          if (node.children) node.children.forEach(dfs);
          return;
        }

        let hasUnsolvedChild = false;
        if (node.children) {
          for (const child of node.children) {
            if (child.type === "bracket" && !child.solved) {
              hasUnsolvedChild = true;
              dfs(child);
            } else if (child.children) {
              dfs(child);
            }
          }
        }
        if (!hasUnsolvedChild) innermost.add(node.id);
      }

      rootNodes.forEach(dfs);
      return innermost;
    }

    function renderPuzzle() {
      if (finalPhase) return;

      const innermost = getInnermostUnsolvedIds();

      function renderNode(node) {
        if (node.type === "text") {
          return document.createTextNode(node.text);
        }

        if (node.solved) {
          return document.createTextNode(node.answer);
        }

        const isInner = innermost.has(node.id);
        const wrapper = document.createElement("span");

        if (isInner) {
          wrapper.className = "bracket-innermost";
          const innerSpan = document.createElement("span");
          innerSpan.className = "bracket-innermost-inner";

          innerSpan.appendChild(document.createTextNode("["));
          node.children.forEach((child) => innerSpan.appendChild(renderNode(child)));
          innerSpan.appendChild(document.createTextNode("]"));

          wrapper.appendChild(innerSpan);
        } else {
          wrapper.appendChild(document.createTextNode("["));
          node.children.forEach((child) => wrapper.appendChild(renderNode(child)));
          wrapper.appendChild(document.createTextNode("]"));
        }

        return wrapper;
      }

      puzzleTextEl.innerHTML = "";
      rootNodes.forEach((n) => puzzleTextEl.appendChild(renderNode(n)));

      const remaining = allBracketNodes.filter((n) => !n.solved).length;
      if (remaining > 0) {
        setStatus("Brackets remaining: " + remaining, "muted");
      } else {
        showFinalSentence();
      }
    }

    // ===== STATUS =====
    function setStatus(msg, tone) {
      statusLineEl.textContent = msg;
      statusLineEl.className = "";
      if (tone) statusLineEl.classList.add(tone);
    }

    // ===== FINAL SENTENCE PHASE =====
    function showFinalSentence() {
      finalPhase = true;

      const container = document.createElement("span");
      const parts = [
        { text: "Cross", isWord: true },
        { text: " ", isWord: false },
        { text: "my", isWord: true },
        { text: " ", isWord: false },
        { text: "heart", isWord: true },
        { text: ",", isWord: false },
        { text: " ", isWord: false },
        { text: "hope", isWord: true },
        { text: " ", isWord: false },
        { text: "to", isWord: true },
        { text: " ", isWord: false },
        { text: "die", isWord: true }
      ];

      parts.forEach((part, idx) => {
        if (!part.isWord) {
          container.appendChild(document.createTextNode(part.text));
        } else {
          const span = document.createElement("span");
          span.className = "final-word";
          span.dataset.index = String(idx);
          span.textContent = part.text;
          container.appendChild(span);
        }
      });

      puzzleTextEl.innerHTML = "";
      puzzleTextEl.appendChild(container);

      const labelEl = document.getElementById("inputLabel");
      if (labelEl) {
        labelEl.textContent = "Finish the rhyme that begins with \"stick\"…";
      }
      answerInput.value = "";
      answerInput.placeholder = "Finish the rhyme that begins with \"stick\"…";
      setStatus(
        "All brackets solved! Now finish the childhood promise to unlock the letter.",
        "good"
      );

      attachFinalWordClicks();
    }

    function attachFinalWordClicks() {
      const wordEls = document.querySelectorAll(".final-word");
      wordEls.forEach((el) => {
        if (oathUnlocked) {
          el.classList.add("secret-ready");
        }
        el.addEventListener("click", () => {
          const word = el.textContent || "";
          handleFinalWordClick(word);
        });
      });
    }

    function handleFinalWordClick(word) {
      if (!oathUnlocked) {
        setStatus(
          "Make the needle promise first, then click the word after \"my\".",
          "bad"
        );
        return;
      }

      if ((word || "").toLowerCase() !== "heart") {
        setStatus("That is not the word immediately after \"my\".", "bad");
        return;
      }

      if (localStorage.getItem(DAY_LETTER_KEY)) {
        openModal("letterModal");
        return;
      }

      localStorage.setItem(DAY_LETTER_KEY, HIDDEN_LETTER);
      alreadyBanner.style.display = "block";
      openModal("letterModal");
    }

    // ===== INPUT HANDLING =====
    function handleSubmit() {
      const raw = answerInput.value.trim();
      if (!raw) return;

      if (!finalPhase) {
        handleBracketAnswer(raw);
      } else {
        handleOathInput(raw);
      }
      answerInput.value = "";
    }

    function handleBracketAnswer(raw) {
      const guess = normalizeAnswer(raw);
      if (!guess) return;

      const target = allBracketNodes.find(
        (n) => !n.solved && n.answerNormalized === guess
      );

      if (!target) {
        setStatus("No unsolved bracket is expecting that answer.", "bad");
        return;
      }

      target.solved = true;
      setStatus("Solved a bracket: " + target.answer, "good");
      renderPuzzle();
    }

    function normalizeOath(str) {
      return str
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, " ")
        .trim();
    }

    function handleOathInput(raw) {
      const norm = normalizeOath(raw);
      if (norm === OATH_TARGET) {
        if (!oathUnlocked) {
          oathUnlocked = true;
          setStatus(
            "Promise accepted. Now click the word that comes immediately after \"my\".",
            "good"
          );
          attachFinalWordClicks();
        } else {
          setStatus(
            "You already made the promise. Click the word after \"my\".",
            "muted"
          );
        }
      } else {
        setStatus(
          "That doesn't quite match the rhyme. Think schoolyard version.",
          "bad"
        );
      }
    }

    // ===== MODALS & NAV =====
    function openModal(id) {
      const modal = document.getElementById(id);
      if (!modal) return;
      modal.classList.add("open");
      modal.setAttribute("aria-hidden", "false");
    }

    function closeModal(id) {
      const modal = document.getElementById(id);
      if (!modal) return;
      modal.classList.remove("open");
      modal.setAttribute("aria-hidden", "true");
    }

    // ===== INIT =====
    function init() {
      if (localStorage.getItem(DAY_LETTER_KEY)) {
        alreadyBanner.style.display = "block";
      }

      buildPuzzle();
      renderPuzzle();

      submitAnswerBtn.addEventListener("click", handleSubmit);
      answerInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter") handleSubmit();
      });

      document.getElementById("backButton").addEventListener("click", () => {
        window.location.href = "../../index.html";
      });

      document
        .getElementById("goHomeFromModal")
        .addEventListener("click", () => {
          window.location.href = "../../index.html";
        });

      document
        .querySelectorAll("[data-close]")
        .forEach((btn) =>
          btn.addEventListener("click", () =>
            closeModal(btn.getAttribute("data-close"))
          )
        );

      document.querySelectorAll(".modal").forEach((modal) => {
        modal.addEventListener("click", (e) => {
          if (e.target === modal) {
            modal.classList.remove("open");
            modal.setAttribute("aria-hidden", "true");
          }
        });
      });

      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape") {
          document
            .querySelectorAll(".modal.open")
            .forEach((m) => m.classList.remove("open"));
        }
      });

      setStatus(
        "Solve any innermost blue bracket to start collapsing the madness.",
        "muted"
      );
    }

    init();
  </script>
</body>
</html>
