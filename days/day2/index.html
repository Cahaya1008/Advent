<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Day 2 – Bracket City</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap" rel="stylesheet" />
  <style>
    :root {
      --panel-bg: #faf5ef;
      --highlight-inner: #adc2ff;
      --correct: #16a34a;
      --error: #b91c1c;
      --text-muted: #6b7280;
      --accent: #7b2333;
      --accent-light: #f4e4d8;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: "Poppins", sans-serif;
      background: radial-gradient(circle at top, #1a2333, #040611 70%);
      min-height: 100vh;
      padding: 1.5rem;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .page {
      background: var(--panel-bg);
      width: 100%;
      max-width: 760px;
      padding: 1.6rem 1.6rem 1.3rem;
      border-radius: 20px;
      box-shadow: 0 10px 35px rgba(0,0,0,0.45);
      position: relative;
    }

    header { text-align: center; margin-bottom: 1rem; }

    header h1 {
      color: var(--accent);
      font-size: 1.8rem;
      margin-bottom: 0.3rem;
    }

    header p {
      font-size: 0.9rem;
      color: var(--text-muted);
    }

    .already-banner {
      position: absolute;
      right: 1rem;
      top: 1rem;
      font-size: 0.8rem;
      padding: 0.3rem 0.8rem;
      border-radius: 999px;
      background: #ecfdf5;
      border: 1px solid #c6f2df;
      color: #065f46;
      display: none;
    }

    #puzzleSentence {
      line-height: 1.6;
      font-size: 1.05rem;
      background: #fff;
      padding: 1rem;
      border-radius: 14px;
      border: 1px solid #e4dfd9;
      margin-bottom: 1rem;
      min-height: 70px;
      word-wrap: break-word;
    }

    .bracket {
      background: var(--highlight-inner);
      border-radius: 6px;
      padding: 0 4px;
      border: 1px dashed #90aaff;
      cursor: pointer;
    }

    #currentClue {
      margin-top: 0.2rem;
      font-size: 0.9rem;
      color: var(--text-muted);
      min-height: 1.2rem;
    }

    #answerInput {
      width: 100%;
      padding: 0.7rem 1rem;
      border-radius: 12px;
      border: 1px solid #d4c8bc;
      margin-top: 0.7rem;
      font-size: 1rem;
    }

    #submitAnswer {
      margin-top: 0.6rem;
      background: var(--accent);
      color: #fff;
      border: none;
      padding: 0.65rem 1.1rem;
      border-radius: 12px;
      font-size: 0.9rem;
      cursor: pointer;
    }

    #submitAnswer:hover {
      box-shadow: 0 4px 12px rgba(0,0,0,0.18);
      transform: translateY(-1px);
    }

    #status {
      margin-top: 0.5rem;
      min-height: 1.2rem;
      font-size: 0.85rem;
    }

    #status.error { color: var(--error); }
    #status.success { color: var(--correct); }

    #stepProgress {
      margin-top: 0.5rem;
      font-size: 0.8rem;
      color: var(--text-muted);
    }

    #hintContainer {
      display: none;
      margin-top: 1rem;
      background: #fef3c7;
      padding: 0.9rem;
      border-radius: 12px;
      border: 1px dashed #fcd34d;
      font-size: 0.88rem;
    }

    footer {
      margin-top: 1.3rem;
      text-align: center;
    }

    .btn {
      background: var(--accent);
      color: white;
      border: none;
      padding: 0.6rem 1rem;
      border-radius: 10px;
      cursor: pointer;
      font-size: 0.9rem;
    }

    .btn-secondary {
      background: var(--accent-light);
      color: #5a4032;
      border: 1px solid #d6c0b4;
    }

    .modal {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.55);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 1rem;
      z-index: 20;
    }

    .modal.open { display: flex; }

    .modal-content {
      background: #fff8f0;
      padding: 1.3rem;
      border-radius: 18px;
      max-width: 380px;
      width: 100%;
      box-shadow: 0 8px 20px rgba(0,0,0,0.5);
      position: relative;
    }

    .modal-close {
      position: absolute;
      right: 0.7rem;
      top: 0.7rem;
      background: none;
      border: none;
      font-size: 1.2rem;
      cursor: pointer;
      color: #555;
    }
  </style>
</head>
<body>
  <div class="page">
    <div class="already-banner" id="alreadyBanner">Letter already collected</div>

    <header>
      <h1>Day 2 – Bracket City</h1>
      <p>Type the answer to <em>any</em> blue bracket and hit Enter. You can solve them in any order.</p>
    </header>

    <div id="puzzleSentence"></div>
    <div id="currentClue"></div>

    <input id="answerInput" placeholder="Type an answer for any blue bracket…" autocomplete="off" />
    <button id="submitAnswer">Submit</button>

    <div id="status"></div>
    <div id="stepProgress"></div>

    <div id="hintContainer">
      <strong>Hint:</strong>
      When the brackets are gone, finish the old childhood rhyme that follows “hope to die.”  
      Type the part that begins with <em>“stick…”</em>
  </div>

    <footer>
      <button class="btn-secondary" id="backBtn">← Back to calendar</button>
    </footer>
  </div>

  <div class="modal" id="letterModal">
    <div class="modal-content">
      <button class="modal-close" data-close="letterModal">&times;</button>
      <h3>Letter collected!</h3>
      <p>Your secret letter has been saved to the calendar.</p>
      <div style="margin-top: 1rem; display: flex; justify-content: flex-end; gap: 0.5rem;">
        <button class="btn-secondary" data-close="letterModal">Stay here</button>
        <button class="btn" id="goHome">Back to calendar</button>
      </div>
    </div>
  </div>

  <script>
    const DAY_KEY = "advent_day_2_letter";
    const HIDDEN_LETTER = "H";
    const FINAL_SENTENCE = "Cross my heart, hope to die";
    const OATH_PHRASE = "stick a needle in my eye";

    const puzzleEl = document.getElementById("puzzleSentence");
    const clueEl = document.getElementById("currentClue");
    const inputEl = document.getElementById("answerInput");
    const statusEl = document.getElementById("status");
    const progressEl = document.getElementById("stepProgress");
    const hintEl = document.getElementById("hintContainer");
    const alreadyBanner = document.getElementById("alreadyBanner");

    let finalPhase = false;

    // --- node helpers ---
    let idCounter = 0;
    function makeId(prefix) {
      idCounter += 1;
      return prefix + "_" + idCounter;
    }
    function textNode(t) { return { type: "text", text: t }; }
    function bracketNode(answer, children) {
      return { type: "bracket", id: makeId("b"), answer, children, solved: false, innermost: false };
    }

    // ===== BUILD PUZZLE =====
    // Cross: C + Ross chain
    const nodePAIN = bracketNode("pain", [
      textNode("what you feel if you accidentally jab your finger with a palette knife")
    ]);
    const nodeJOY = bracketNode("joy", [
      textNode('emotion in the title of Bob Ross’s show, "The ___ of Painting"')
    ]);
    const nodeROSS = bracketNode("Ross", [
      textNode("famous "),
      nodePAIN,
      textNode("ter Bob ____ who hosted the "),
      nodeJOY,
      textNode(" of Painting")
    ]);

    // HEART mega-chain (fixed to avoid repeated phrases)
    const nodeMUSCLE = bracketNode("muscle", [
      textNode("type of tissue that contracts to move or pump parts of your body")
    ]);

    const nodeCARDIAC = bracketNode("cardiac", [
      textNode("kind of "),
      nodeMUSCLE,
      textNode(" found only in the organ that pumps blood")
    ]);

    const nodeCHAMBERS = bracketNode("4", [
      textNode("number of chambers in a human heart made of "),
      nodeCARDIAC
    ]);

    const nodeVALENTINE = bracketNode("Valentine", [
      textNode("holiday famous for cards covered in little cartoon hearts")
    ]);

    const nodeFEBRUARY = bracketNode("February", [
      textNode("month that includes "),
      nodeVALENTINE,
      textNode("'s Day")
    ]);

    const nodeFOURTEEN = bracketNode("14", [
      textNode("day of "),
      nodeFEBRUARY,
      textNode(" on which "),
      nodeVALENTINE,
      textNode("'s Day is celebrated")
    ]);

    const nodeHEARTS = bracketNode("hearts", [
      textNode("playing-card suit that uses the same symbol drawn on "),
      nodeVALENTINE,
      textNode("'s Day cards")
    ]);

    const nodeHEART = bracketNode("heart", [
      textNode("organ with "),
      nodeCHAMBERS,
      textNode(" chambers whose symbol on "),
      nodeVALENTINE,
      textNode("'s Day cards is the "),
      nodeHEARTS,
      textNode(" suit")
    ]);

    // HOPE chain
    const nodeEVITA = bracketNode("Evita", [
      textNode("Andrew Lloyd Webber musical about Argentine First Lady Eva Perón")
    ]);
    const nodeDESPAIR = bracketNode("despair", [
      textNode("what theatre fans might feel if "),
      nodeEVITA,
      textNode(" closed the night before opening")
    ]);
    const nodeHOPE = bracketNode("hope", [
      textNode("opposite of "),
      nodeDESPAIR
    ]);

    // DIE mega-chain
        // electron appears only once as an innermost clue
    const nodeELECTRON = bracketNode("electron", [
      textNode("subatomic particle discovered by J.J. Thomson")
    ]);

    const nodeNEGATIVE = bracketNode("negative", [
      textNode("electric charge carried by an "),
      nodeELECTRON,
      textNode(" in an atom")
    ]);

    const nodeANION = bracketNode("anion", [
      textNode("ion that has a "),
      nodeNEGATIVE,
      textNode(" charge")
    ]);

    const nodeHALOGEN = bracketNode("halogen", [
      textNode("periodic-table group (like fluorine and chlorine) that easily forms an "),
      nodeANION
    ]);

    const nodeCHLORIDE = bracketNode("chloride", [
      textNode("ion formed when a "),
      nodeHALOGEN,
      textNode(" such as chlorine gains an extra electron")
    ]);

    const nodeNACL = bracketNode("NaCl", [
      textNode("chemical formula made of sodium and "),
      nodeCHLORIDE
    ]);
    const nodeIONIC = bracketNode("ionic", [
      textNode("type of bond in "),
      nodeNACL,
      textNode(" (as in a(n) ___ bond)")
    ]);
    const nodeBONDWORD = bracketNode("Bond", [
      textNode("surname shared by this kind of "),
      nodeIONIC,
      textNode(" bond and fictional agent James ___")
    ]);
    const nodeFLEMING = bracketNode("Fleming", [
      textNode("author Ian ______ who created James "),
      nodeBONDWORD
    ]);
    const nodeGOLDENEYE = bracketNode("GoldenEye", [
      textNode("Nintendo shooter based on a film about the character created by "),
      nodeFLEMING
    ]);
    const nodeN64 = bracketNode("N64", [
      textNode("abbreviated nickname of the console that hosted "),
      nodeGOLDENEYE
    ]);
    const node1996 = bracketNode("1996", [
      textNode("year the "),
      nodeN64,
      textNode(" launched in North America")
    ]);
    const nodeMOORE = bracketNode("Moore", [
      textNode("surname of Roger _____, who played James Bond long before "),
      node1996
    ]);
    const nodeTITLE = bracketNode("LiveAndLetDie", [
      textNode("Bond film starring Roger "),
      nodeMOORE,
      textNode(' whose title, written without spaces, is this answer')
    ]);
    const nodeDIE = bracketNode("die", [
      textNode("final word of the title "),
      nodeTITLE
    ]);

    const rootNodes = [
      textNode("C"),
      nodeROSS,
      textNode(" my "),
      nodeHEART,
      textNode(", "),
      nodeHOPE,
      textNode(" to "),
      nodeDIE
    ];

    // ===== COLLECT BRACKETS =====
    const allBrackets = [];
    const bracketById = {};
    function collectBrackets(nodes) {
      for (const n of nodes) {
        if (n.type === "bracket") {
          allBrackets.push(n);
          bracketById[n.id] = n;
          collectBrackets(n.children);
        }
      }
    }
    collectBrackets(rootNodes);

    // ===== HELPERS =====
    function computeInnermostFlags(nodes) {
      function recurse(node) {
        if (node.type === "text") return;
        let hasUnsolvedChild = false;
        for (const child of node.children) {
          if (child.type === "bracket") {
            recurse(child);
            if (!child.solved) hasUnsolvedChild = true;
          }
        }
        node.innermost = !node.solved && !hasUnsolvedChild;
      }
      nodes.forEach(n => { if (n.type === "bracket") recurse(n); });
    }

    function getBracketDisplayText(node) {
      function renderChildren(children) {
        let s = "";
        for (const child of children) {
          if (child.type === "text") s += child.text;
          else if (child.type === "bracket") {
            if (child.solved) s += child.answer;
            else s += "[" + renderChildren(child.children) + "]";
          }
        }
        return s;
      }
      return "[" + renderChildren(node.children) + "]";
    }

    // ===== RENDERING =====
    let selectedId = null;

    function renderNodes(nodes, parentEl) {
      for (const node of nodes) {
        if (node.type === "text") {
          parentEl.appendChild(document.createTextNode(node.text));
        } else if (node.type === "bracket") {
          if (node.solved) {
            parentEl.appendChild(document.createTextNode(node.answer));
          } else if (node.innermost) {
            const span = document.createElement("span");
            span.className = "bracket";
            span.dataset.id = node.id;
            span.addEventListener("click", () => {
              selectedId = node.id;
              clueEl.textContent = "Selected clue: " + getBracketDisplayText(node);
              statusEl.textContent = "";
              statusEl.className = "";
              inputEl.focus();
            });
            span.appendChild(document.createTextNode("["));
            renderNodes(node.children, span);
            span.appendChild(document.createTextNode("]"));
            parentEl.appendChild(span);
          } else {
            parentEl.appendChild(document.createTextNode("["));
            renderNodes(node.children, parentEl);
            parentEl.appendChild(document.createTextNode("]"));
          }
        }
      }
    }

    function renderPuzzle() {
      computeInnermostFlags(rootNodes);
      puzzleEl.innerHTML = "";
      renderNodes(rootNodes, puzzleEl);
      updateProgress();
    }

    function updateProgress() {
      const total = allBrackets.length;
      const solved = allBrackets.filter(b => b.solved).length;
      progressEl.textContent = `Solved ${solved} of ${total} brackets`;
    }

    function allSolved() {
      return allBrackets.every(b => b.solved);
    }

    function getInnermostUnsolvedBrackets() {
      return allBrackets.filter(b => b.innermost && !b.solved);
    }

    // ===== ANSWERING =====
    function submitAnswer() {
      const guessRaw = (inputEl.value || "").trim();
      if (!guessRaw) {
        statusEl.textContent = "Type an answer.";
        statusEl.className = "error";
        return;
      }

      if (finalPhase) {
        const normalized = guessRaw.toLowerCase();
        if (localStorage.getItem(DAY_KEY)) {
          openModal("letterModal");
          return;
        }
        if (normalized === OATH_PHRASE) {
          statusEl.textContent = "Oath accepted.";
          statusEl.className = "success";
          inputEl.value = "";
          localStorage.setItem(DAY_KEY, HIDDEN_LETTER);
          alreadyBanner.style.display = "block";
          openModal("letterModal");
        } else {
          statusEl.textContent = 'The oath has to be exactly "stick a needle in my eye".';
          statusEl.className = "error";
        }
        return;
      }

      const guess = guessRaw.toUpperCase();

      if (selectedId) {
        const node = bracketById[selectedId];
        if (node && !node.solved && guess === node.answer.toUpperCase()) {
          solveBracket(node);
          return;
        }
      }

      const candidates = getInnermostUnsolvedBrackets();
      const match = candidates.find(b => guess === b.answer.toUpperCase());

      if (match) {
        solveBracket(match);
      } else {
        statusEl.textContent = "No innermost bracket matches that answer. Check spelling?";
        statusEl.className = "error";
      }
    }

    function solveBracket(node) {
      node.solved = true;
      statusEl.textContent = "Correct!";
      statusEl.className = "success";
      selectedId = null;
      clueEl.textContent = "";
      inputEl.value = "";

      if (allSolved()) {
        showFinalSentence();
      } else {
        renderPuzzle();
      }
    }

    // ===== FINAL PHASE =====
    function showFinalSentence() {
      finalPhase = true;
      puzzleEl.textContent = FINAL_SENTENCE;
      statusEl.textContent = "";
      statusEl.className = "";
      clueEl.textContent = "";
      progressEl.textContent = "";
      hintEl.style.display = "block";
      inputEl.value = "";
      inputEl.placeholder = "Finish the rhyme…";
    }

    // ===== MODAL / NAV =====
    function openModal(id) {
      document.getElementById(id).classList.add("open");
    }
    function closeModal(id) {
      document.getElementById(id).classList.remove("open");
    }

    document.querySelectorAll("[data-close]").forEach(btn => {
      btn.addEventListener("click", () => closeModal(btn.dataset.close));
    });

    document.getElementById("backBtn").addEventListener("click", () => {
      window.location.href = "../../index.html";
    });
    document.getElementById("goHome").addEventListener("click", () => {
      window.location.href = "../../index.html";
    });
    document.getElementById("submitAnswer").addEventListener("click", submitAnswer);

    document.addEventListener("keydown", e => {
      if (e.key === "Enter") submitAnswer();
      else if (e.key === "Escape") closeModal("letterModal");
    });

    // ===== INIT =====
    if (localStorage.getItem(DAY_KEY)) {
      alreadyBanner.style.display = "block";
    }
    renderPuzzle();
  </script>
</body>
</html>
