<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Day 2 – Bracket City</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap" rel="stylesheet" />
  <style>
    :root {
      --panel-bg: #faf5ef;
      --highlight: #dfe7ff;
      --highlight-inner: #adc2ff;
      --correct: #16a34a;
      --error: #b91c1c;
      --text-muted: #6b7280;
      --accent: #7b2333;
      --accent-light: #f4e4d8;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: "Poppins", sans-serif;
      background: radial-gradient(circle at top, #1a2333, #040611 70%);
      min-height: 100vh;
      padding: 1.5rem;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .page {
      background: var(--panel-bg);
      width: 100%;
      max-width: 760px;
      padding: 1.6rem 1.6rem 1.3rem;
      border-radius: 20px;
      box-shadow: 0 10px 35px rgba(0,0,0,0.45);
      position: relative;
    }

    header { text-align: center; margin-bottom: 1rem; }

    header h1 {
      color: var(--accent);
      font-size: 1.8rem;
      margin-bottom: 0.3rem;
    }

    header p {
      font-size: 0.9rem;
      color: var(--text-muted);
    }

    .already-banner {
      position: absolute;
      right: 1rem;
      top: 1rem;
      font-size: 0.8rem;
      padding: 0.3rem 0.8rem;
      border-radius: 999px;
      background: #ecfdf5;
      border: 1px solid #c6f2df;
      color: #065f46;
      display: none;
    }

    #puzzleSentence {
      line-height: 1.6;
      font-size: 1.05rem;
      background: #fff;
      padding: 1rem;
      border-radius: 14px;
      border: 1px solid #e4dfd9;
      margin-bottom: 1rem;
      min-height: 70px;
      word-wrap: break-word;
    }

    .bracket {
      background: var(--highlight);
      border-radius: 6px;
      padding: 0 4px;
      border: 1px dashed #90aaff;
      cursor: default;
    }

    .bracket.innermost {
      background: var(--highlight-inner);
      cursor: pointer;
    }

    #currentClue {
      margin-top: 0.2rem;
      font-size: 0.9rem;
      color: var(--text-muted);
      min-height: 1.2rem;
    }

    #answerInput {
      width: 100%;
      padding: 0.7rem 1rem;
      border-radius: 12px;
      border: 1px solid #d4c8bc;
      margin-top: 0.7rem;
      font-size: 1rem;
    }

    #submitAnswer {
      margin-top: 0.6rem;
      background: var(--accent);
      color: #fff;
      border: none;
      padding: 0.65rem 1.1rem;
      border-radius: 12px;
      font-size: 0.9rem;
      cursor: pointer;
    }

    #submitAnswer:hover {
      box-shadow: 0 4px 12px rgba(0,0,0,0.18);
      transform: translateY(-1px);
    }

    #status {
      margin-top: 0.5rem;
      min-height: 1.2rem;
      font-size: 0.85rem;
    }

    #status.error { color: var(--error); }
    #status.success { color: var(--correct); }

    #stepProgress {
      margin-top: 0.5rem;
      font-size: 0.8rem;
      color: var(--text-muted);
    }

    #hintContainer {
      display: none;
      margin-top: 1rem;
      background: #fef3c7;
      padding: 0.9rem;
      border-radius: 12px;
      border: 1px dashed #fcd34d;
      font-size: 0.88rem;
    }

    .final-word {
      display: inline-block;
      padding: 1px 4px;
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.1s;
    }

    .final-word:hover {
      background: #fee2e2;
    }

    .final-word.correct {
      background: #dcfce7;
    }

    .final-word.disabled {
      cursor: default;
      pointer-events: none;
    }

    footer {
      margin-top: 1.3rem;
      text-align: center;
    }

    .btn {
      background: var(--accent);
      color: white;
      border: none;
      padding: 0.6rem 1rem;
      border-radius: 10px;
      cursor: pointer;
      font-size: 0.9rem;
    }

    .btn-secondary {
      background: var(--accent-light);
      color: #5a4032;
      border: 1px solid #d6c0b4;
    }

    /* modal */

    .modal {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.55);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 1rem;
      z-index: 20;
    }

    .modal.open { display: flex; }

    .modal-content {
      background: #fff8f0;
      padding: 1.3rem;
      border-radius: 18px;
      max-width: 380px;
      width: 100%;
      box-shadow: 0 8px 20px rgba(0,0,0,0.5);
      position: relative;
    }

    .modal-close {
      position: absolute;
      right: 0.7rem;
      top: 0.7rem;
      background: none;
      border: none;
      font-size: 1.2rem;
      cursor: pointer;
      color: #555;
    }
  </style>
</head>
<body>
  <div class="page">
    <div class="already-banner" id="alreadyBanner">Letter already collected</div>

    <header>
      <h1>Day 2 – Bracket City</h1>
      <p>Solve any innermost bracket. When all brackets vanish, the sentence appears and hides today’s letter.</p>
    </header>

    <div id="puzzleSentence"></div>
    <div id="currentClue"></div>

    <input id="answerInput" placeholder="Type answer for selected bracket…" autocomplete="off" />
    <button id="submitAnswer">Submit</button>

    <div id="status"></div>
    <div id="stepProgress"></div>

    <div id="hintContainer">
      <strong>Letter hint:</strong>
      In the final sentence, click the word that comes immediately after “my”. The secret letter is the first letter of that word.
    </div>

    <footer>
      <button class="btn-secondary" id="backBtn">← Back to calendar</button>
    </footer>
  </div>

  <div class="modal" id="letterModal">
    <div class="modal-content">
      <button class="modal-close" data-close="letterModal">&times;</button>
      <h3>Letter collected!</h3>
      <p>Your secret letter has been saved to the calendar.</p>
      <div style="margin-top: 1rem; display: flex; justify-content: flex-end; gap: 0.5rem;">
        <button class="btn-secondary" data-close="letterModal">Stay here</button>
        <button class="btn" id="goHome">Back to calendar</button>
      </div>
    </div>
  </div>

  <script>
    // ===== basic config =====
    const DAY_KEY = "advent_day_2_letter";
    const HIDDEN_LETTER = "H"; // first letter of "heart"
    const FINAL_SENTENCE = "Cross my heart, hope to die";
    const CORRECT_WORD_INDEX = 2; // 0-based: ["Cross","my","heart,","hope","to","die"]

    const puzzleEl = document.getElementById("puzzleSentence");
    const clueEl = document.getElementById("currentClue");
    const inputEl = document.getElementById("answerInput");
    const statusEl = document.getElementById("status");
    const progressEl = document.getElementById("stepProgress");
    const hintEl = document.getElementById("hintContainer");
    const alreadyBanner = document.getElementById("alreadyBanner");

    // ===== Bracket tree model =====
    // Node shape:
    // { type: 'text', text }
    // { type: 'bracket', id, answer, children: [...], solved: false, innermost: false }

    let idCounter = 0;
    function makeId(prefix) {
      idCounter += 1;
      return prefix + "_" + idCounter;
    }

    function textNode(t) {
      return { type: "text", text: t };
    }

    function bracketNode(answer, children) {
      return {
        type: "bracket",
        id: makeId("b"),
        answer,
        children,
        solved: false,
        innermost: false
      };
    }

    // Build puzzle:
    //
    // C[ROSS] my [HEART], [HOPE] to [DIE]

    // CROSS: C + outer bracket that uses nested PAIN / JOY
    const nodePAIN = bracketNode("PAIN", [
      textNode("the feeling if you cut your finger with a knife")
    ]);

    const nodeJOY = bracketNode("JOY", [
      textNode("emotion the same as happiness")
    ]);

    const nodeROSS = bracketNode("ROSS", [
      textNode("famous "),
      nodePAIN,
      textNode("ter Bob ____ who hosted the "),
      nodeJOY,
      textNode(" of painting")
    ]);

    // HEART: nested HEARTS -> HEART
    const nodeHEARTS = bracketNode("HEARTS", [
      textNode("poker suit represented by the ♥ symbol")
    ]);

    const nodeHEART = bracketNode("HEART", [
      textNode("singular form of "),
      nodeHEARTS
    ]);

    // HOPE: nested EVITA -> DESPAIR -> HOPE
    const nodeEVITA = bracketNode("EVITA", [
      textNode('Andrew Lloyd Webber musical about the First Lady of Argentina')
    ]);

    const nodeDESPAIR = bracketNode("DESPAIR", [
      textNode("what you might feel if "),
      nodeEVITA,
      textNode(' ended with "Don\'t Hope for Me, Argentina" instead')
    ]);

    const nodeHOPE = bracketNode("HOPE", [
      textNode("opposite of "),
      nodeDESPAIR
    ]);

    // DIE: simple but precise
    const nodeDIE = bracketNode("DIE", [
      textNode('word that finishes the James Bond film title "Live and Let ___"')
    ]);

    // Root sequence
    const rootNodes = [
      textNode("C"),
      nodeROSS,
      textNode(" my "),
      nodeHEART,
      textNode(", "),
      nodeHOPE,
      textNode(" to "),
      nodeDIE
    ];

    // Collect all bracket nodes for progress & lookup
    const allBrackets = [];
    const bracketById = {};

    function collectBrackets(nodes) {
      for (const n of nodes) {
        if (n.type === "bracket") {
          allBrackets.push(n);
          bracketById[n.id] = n;
          collectBrackets(n.children);
        }
      }
    }
    collectBrackets(rootNodes);

    // ===== helpers =====

    function computeInnermostFlags(nodes) {
      function recurse(node) {
        if (node.type === "text") return;

        let hasUnsolvedChild = false;
        for (const child of node.children) {
          if (child.type === "bracket") {
            recurse(child);
            if (!child.solved) hasUnsolvedChild = true;
          }
        }
        node.innermost = !node.solved && !hasUnsolvedChild;
      }
      nodes.forEach(n => {
        if (n.type === "bracket") recurse(n);
      });
    }

    function getBracketDisplayText(node) {
      // For "Current clue" – show bracket as it currently appears.
      function renderChildren(children) {
        let s = "";
        for (const child of children) {
          if (child.type === "text") s += child.text;
          else if (child.type === "bracket") {
            if (child.solved) {
              s += child.answer;
            } else {
              s += "[" + renderChildren(child.children) + "]";
            }
          }
        }
        return s;
      }
      return "[" + renderChildren(node.children) + "]";
    }

    // ===== rendering =====

    let selectedId = null;

    function renderNodes(nodes, parentEl) {
      for (const node of nodes) {
        if (node.type === "text") {
          parentEl.appendChild(document.createTextNode(node.text));
        } else if (node.type === "bracket") {
          if (node.solved) {
            parentEl.appendChild(document.createTextNode(node.answer));
          } else {
            const span = document.createElement("span");
            span.className = "bracket";
            if (node.innermost) {
              span.classList.add("innermost");
              span.addEventListener("click", () => {
                selectedId = node.id;
                clueEl.textContent = "Current clue: " + getBracketDisplayText(node);
                statusEl.textContent = "";
                statusEl.className = "";
                inputEl.value = "";
                inputEl.focus();
              });
            }
            span.dataset.id = node.id;

            span.appendChild(document.createTextNode("["));
            renderNodes(node.children, span);
            span.appendChild(document.createTextNode("]"));

            parentEl.appendChild(span);
          }
        }
      }
    }

    function renderPuzzle() {
      computeInnermostFlags(rootNodes);
      puzzleEl.innerHTML = "";
      renderNodes(rootNodes, puzzleEl);
      updateProgress();
    }

    function updateProgress() {
      const total = allBrackets.length;
      const solved = allBrackets.filter(b => b.solved).length;
      progressEl.textContent = `Solved ${solved} of ${total} brackets`;
    }

    function allSolved() {
      return allBrackets.every(b => b.solved);
    }

    // ===== answering =====

    function submitAnswer() {
      if (!selectedId) {
        statusEl.textContent = "Click an innermost bracket first.";
        statusEl.className = "error";
        return;
      }
      const node = bracketById[selectedId];
      if (!node || node.solved) {
        statusEl.textContent = "Pick an unsolved innermost bracket.";
        statusEl.className = "error";
        return;
      }

      const guess = (inputEl.value || "").trim().toUpperCase();
      if (!guess) {
        statusEl.textContent = "Type an answer.";
        statusEl.className = "error";
        return;
      }

      if (guess === node.answer.toUpperCase()) {
        node.solved = true;
        statusEl.textContent = "Correct!";
        statusEl.className = "success";
        selectedId = null;
        clueEl.textContent = "";
        inputEl.value = "";

        if (allSolved()) {
          showFinalSentence();
        } else {
          renderPuzzle();
        }
      } else {
        statusEl.textContent = "Not quite. Try again.";
        statusEl.className = "error";
      }
    }

    // ===== final phase =====

    function showFinalSentence() {
      // Render final sentence as clickable words instead of bracket structure
      puzzleEl.innerHTML = "";
      statusEl.textContent = "";
      statusEl.className = "";
      clueEl.textContent = "";
      progressEl.textContent = "";

      const words = FINAL_SENTENCE.split(" ");
      words.forEach((w, idx) => {
        const span = document.createElement("span");
        span.textContent = w;
        span.className = "final-word";
        span.dataset.index = idx.toString();

        span.addEventListener("click", () => onFinalWordClick(idx, span));

        puzzleEl.appendChild(span);
        if (idx !== words.length - 1) {
          puzzleEl.appendChild(document.createTextNode(" "));
        }
      });

      hintEl.style.display = "block";
    }

    function onFinalWordClick(index, span) {
      // If letter already collected, just show modal.
      if (localStorage.getItem(DAY_KEY)) {
        openModal("letterModal");
        return;
      }

      if (index === CORRECT_WORD_INDEX) {
        span.classList.add("correct");
        span.classList.add("disabled");
        localStorage.setItem(DAY_KEY, HIDDEN_LETTER);
        alreadyBanner.style.display = "block";
        openModal("letterModal");

        // Disable all words
        document.querySelectorAll(".final-word").forEach(w => {
          w.classList.add("disabled");
        });
      } else {
        statusEl.textContent = "That’s not the word the hint is pointing to.";
        statusEl.className = "error";
      }
    }

    // ===== modal / nav =====

    function openModal(id) {
      document.getElementById(id).classList.add("open");
    }

    function closeModal(id) {
      document.getElementById(id).classList.remove("open");
    }

    document.querySelectorAll("[data-close]").forEach(btn => {
      btn.addEventListener("click", () => closeModal(btn.dataset.close));
    });

    document.getElementById("backBtn").addEventListener("click", () => {
      window.location.href = "../../index.html";
    });

    document.getElementById("goHome").addEventListener("click", () => {
      window.location.href = "../../index.html";
    });

    document.getElementById("submitAnswer").addEventListener("click", submitAnswer);

    document.addEventListener("keydown", e => {
      if (e.key === "Enter") {
        submitAnswer();
      } else if (e.key === "Escape") {
        closeModal("letterModal");
      }
    });

    // ===== init =====

    if (localStorage.getItem(DAY_KEY)) {
      alreadyBanner.style.display = "block";
    }

    renderPuzzle();
  </script>
</body>
</html>
