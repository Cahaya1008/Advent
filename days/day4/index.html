<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Day 4 ‚Äì Puzzle</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link
    href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap"
    rel="stylesheet"
  />
  <style>
    :root {
      --bg: #020617;
      --panel: #0b1220;
      --accent: #f97373;
      --accent-soft: #fee2e2;
      --text-main: #f9fafb;
      --muted: #9ca3af;
      --good: #22c55e;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: "Poppins", system-ui, -apple-system, BlinkMacSystemFont,
        "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #111827 0, #020617 55%, #000 100%);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 1.5rem 0.75rem;
      color: var(--text-main);
    }

    .page {
      max-width: 960px;
      width: 100%;
      background: linear-gradient(135deg, #020617, #020617 40%, #020617 100%);
      border-radius: 22px;
      box-shadow: 0 18px 45px rgba(0, 0, 0, 0.7);
      padding: 1.7rem 1.6rem 1.3rem;
      position: relative;
      border: 1px solid rgba(148, 163, 184, 0.25);
    }

    header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 1rem;
      margin-bottom: 1.1rem;
    }

    .header-left {
      flex: 1;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      font-size: 0.8rem;
      background: rgba(248, 250, 252, 0.06);
      padding: 0.24rem 0.6rem;
      border-radius: 999px;
      margin-bottom: 0.35rem;
      border: 1px solid rgba(248, 250, 252, 0.15);
    }

    h1 {
      font-size: 1.9rem;
      margin-bottom: 0.15rem;
    }

    header p {
      font-size: 0.9rem;
      color: var(--muted);
    }

    .already-banner {
      position: absolute;
      top: 0.7rem;
      right: 0.9rem;
      font-size: 0.75rem;
      background: rgba(22, 163, 74, 0.12);
      border-radius: 999px;
      padding: 0.18rem 0.6rem;
      border: 1px solid rgba(74, 222, 128, 0.7);
      color: #bbf7d0;
      display: none;
    }

    main {
      margin-top: 0.3rem;
      display: grid;
      grid-template-columns: minmax(0, 3fr) minmax(220px, 1fr);
      gap: 1rem;
    }

    .puzzle-area {
      position: relative;
      background: radial-gradient(circle at top, #020617, #020617 70%, #000 100%);
      border-radius: 18px;
      padding: 0.8rem;
      border: 1px solid rgba(148, 163, 184, 0.35);
      min-height: 520px;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      gap: 0.7rem;
    }

    .board-wrapper {
      display: flex;
      justify-content: center;
    }

    .board {
  position: relative;
  /* darker background for contrast with pieces */
  background: #020617;
  border-radius: 14px;

  /* much clearer outline + soft glow */
  box-shadow:
    0 0 0 2px rgba(248, 250, 252, 0.45),
    0 0 28px rgba(15, 23, 42, 0.9);

  overflow: hidden;
  width: 400px;   /* 10 * 40 */
  height: 400px;  /* 10 * 40 */

  /* subtle grid so she can see the puzzle cells, but no image preview */
  background-image:
    linear-gradient(
      to right,
      rgba(148, 163, 184, 0.22) 1px,
      transparent 1px
    ),
    linear-gradient(
      to bottom,
      rgba(148, 163, 184, 0.22) 1px,
      transparent 1px
    );
  background-size: 40px 40px; /* lines match piece size */
}


    .piece-tray {
      margin-top: 0.2rem;
      background: rgba(15, 23, 42, 0.95);
      border-radius: 12px;
      border: 1px solid rgba(148, 163, 184, 0.55);
      padding: 0.35rem 0.5rem;
      display: flex;
      align-items: center;
      gap: 0.35rem;
      overflow-x: auto;
      overflow-y: hidden;
      scrollbar-width: thin;
      scrollbar-color: #4b5563 #020617;
      min-height: 56px;
    }

    .piece-tray::-webkit-scrollbar {
      height: 6px;
    }

    .piece-tray::-webkit-scrollbar-track {
      background: #020617;
    }

    .piece-tray::-webkit-scrollbar-thumb {
      background: #4b5563;
      border-radius: 999px;
    }

    .piece {
      position: absolute; /* when in board area */
      width: 40px;
      height: 40px;
      border-radius: 7px;
      background-image: url("../../img/day4.jpg");
      background-size: 400px 400px;
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.7);
      cursor: grab;
      touch-action: none;
      transition: box-shadow 0.12s ease, transform 0.12s ease;
      z-index: 2;
    }

    .piece.in-tray {
      position: static; /* while it's still in the tray row */
      flex: 0 0 auto;
      box-shadow: 0 0 0 1px rgba(75, 85, 99, 0.8);
      cursor: grab;
    }

    .piece.dragging {
      cursor: grabbing;
      box-shadow: 0 14px 30px rgba(0, 0, 0, 0.9);
      transform: scale(1.03);
      z-index: 5;
    }

    .piece.locked {
      cursor: default;
      box-shadow: 0 0 0 1px rgba(148, 163, 184, 0.8);
      z-index: 3;
    }

    .piece.placed {
      box-shadow: 0 0 0 2px rgba(34, 197, 94, 0.7);
      transition: box-shadow 0.2s ease, transform 0.1s ease;
    }

    .info-panel {
      background: rgba(15, 23, 42, 0.9);
      border-radius: 18px;
      padding: 0.8rem 0.9rem 0.9rem;
      border: 1px solid rgba(148, 163, 184, 0.35);
      font-size: 0.85rem;
    }

    .info-panel h2 {
      font-size: 1rem;
      margin-bottom: 0.4rem;
    }

    .info-panel p {
      color: var(--muted);
      margin-bottom: 0.4rem;
      line-height: 1.5;
    }

    .btn {
      border-radius: 999px;
      border: none;
      padding: 0.45rem 0.9rem;
      font-size: 0.83rem;
      font-weight: 500;
      cursor: pointer;
      background: var(--accent-soft);
      color: #991b1b;
      border: 1px solid rgba(248, 113, 113, 0.5);
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
      transition: background 0.12s ease, transform 0.08s ease,
        box-shadow 0.12s ease;
    }

    .btn:hover {
      background: #fecaca;
      transform: translateY(-1px);
      box-shadow: 0 3px 10px rgba(0, 0, 0, 0.35);
    }

    .btn-primary {
      background: #f97373;
      color: #111827;
      border-color: #fecaca;
    }

    .btn-primary:hover {
      background: #fca5a5;
    }

    .btn[disabled] {
      opacity: 0.5;
      cursor: default;
      box-shadow: none;
      transform: none;
    }

    .status {
      margin-top: 0.4rem;
      min-height: 1.1rem;
      color: var(--muted);
    }

    .status-good {
      color: var(--good);
    }

    footer {
      margin-top: 1rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.6rem;
      flex-wrap: wrap;
      font-size: 0.78rem;
      color: var(--muted);
    }

    /* Back-of-puzzle overlay */
    .puzzle-back-overlay {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle at top, #020617, #020617 55%, #000 100%);
      border-radius: 18px;
      pointer-events: none;
      opacity: 0;
      transform: scale(0.9);
      transition: opacity 0.6s ease, transform 0.6s ease;
      z-index: 8;
    }

    .puzzle-back-overlay.show {
      opacity: 1;
      transform: scale(1);
    }

    .puzzle-back-card {
      width: 400px;
      height: 400px;
      border-radius: 18px;
      border: 1px solid rgba(248, 250, 252, 0.15);
      background: radial-gradient(circle at top, #1f2937, #020617 70%);
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }

    .puzzle-back-card::before {
      content: "Back of the puzzle";
      position: absolute;
      top: 0.75rem;
      left: 1rem;
      font-size: 0.8rem;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      color: rgba(209, 213, 219, 0.8);
    }

    .puzzle-back-letter {
      font-size: 9rem;
      font-weight: 700;
      color: #f97373;
      text-shadow: 0 0 45px rgba(248, 113, 113, 0.7);
    }

    /* Modal */

    .modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.6);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 1rem;
      z-index: 40;
    }

    .modal.open {
      display: flex;
    }

    .modal-content {
      max-width: 420px;
      width: 100%;
      padding: 1.2rem 1.3rem 1.05rem;
      background: #0b1220;
      border-radius: 18px;
      color: #e5e7eb;
      position: relative;
      box-shadow: 0 16px 40px rgba(0, 0, 0, 0.8);
      border: 1px solid rgba(148, 163, 184, 0.6);
    }

    .modal h2 {
      font-size: 1.1rem;
      margin-bottom: 0.35rem;
    }

    .modal p {
      font-size: 0.9rem;
      line-height: 1.5;
      color: #cbd5f5;
    }

    .modal-close {
      position: absolute;
      right: 0.7rem;
      top: 0.6rem;
      border: none;
      background: transparent;
      font-size: 1.2rem;
      cursor: pointer;
      color: #9ca3af;
    }

    .modal-footer {
      margin-top: 0.9rem;
      display: flex;
      justify-content: flex-end;
      gap: 0.5rem;
      flex-wrap: wrap;
    }
  </style>
</head>
<body>
  <div class="page">
    <div class="already-banner" id="alreadyBanner">
      Letter already collected ‚úÖ
    </div>

    <header>
      <div class="header-left">
        <div class="badge">
          <span>Day 4</span>
          <span>Jigsaw Puzzle</span>
        </div>
        <h1>Piece it together</h1>
        <p>
          All the puzzle pieces are tucked into a tray at the bottom. Drag them up
          onto the board and snap them into place. When everything fits, flip the
          puzzle over to see what‚Äôs on the back.
        </p>
      </div>
    </header>

    <main>
      <section class="puzzle-area" id="puzzleArea">
        <div class="board-wrapper">
          <div class="board" id="board"></div>
        </div>

        <div class="piece-tray" id="piecesTray"></div>

        <!-- Back-of-puzzle overlay -->
        <div class="puzzle-back-overlay" id="puzzleBackOverlay">
          <div class="puzzle-back-card">
            <div class="puzzle-back-letter">V</div>
          </div>
        </div>
      </section>

      <section class="info-panel">
        <h2>How to play</h2>
        <p>
          Scroll through the tray at the bottom to find pieces. Drag a piece onto
          the board; if you drop it close enough to its true spot, it will snap and
          lock in. The very bottom-left corner piece of the whole image is already fixed
          as your anchor.
        </p>
        <p>
          There‚Äôs no preview here ‚Äî you‚Äôre building the picture from memory and vibes.
          Once every piece is locked in, you‚Äôll be able to inspect the back and reveal
          the hidden letter.
        </p>
        <button class="btn" id="shuffleBtn">‚Üª Return loose pieces to the tray (scrambled)</button>
        <button class="btn" id="inspectBtn" disabled>üëÄ Inspect back of puzzle</button>
        <button class="btn btn-primary" id="backBtn">‚Üê Back to calendar</button>
        <div class="status" id="statusLine">
          Start with corner and edge pieces. The tray scrolls if you need more.
        </div>
      </section>
    </main>

    <footer>
      <span>Tip: Pieces snap when you‚Äôre close enough to the correct grid cell.</span>
      <span>Each day hides at most one letter.</span>
    </footer>
  </div>

  <!-- Letter modal -->
  <div class="modal" id="letterModal" aria-hidden="true">
    <div class="modal-content">
      <button class="modal-close" data-close="letterModal">&times;</button>
      <h2>The back of the puzzle üß©</h2>
      <p>
        On the reverse side of the finished puzzle, one bold letter stands alone:
        <strong>V</strong>. It‚Äôs now been added to your letter collection on the main
        calendar page.
      </p>
      <div class="modal-footer">
        <button class="btn" data-close="letterModal">Stay on this page</button>
        <button class="btn btn-primary" id="goHomeFromModal">Back to calendar</button>
      </div>
    </div>
  </div>

  <script>
    // ===== CONFIG =====
    const ROWS = 10;
    const COLS = 10;
    const PIECE_SIZE = 40; // must match CSS .piece size and board size
    const SNAP_DISTANCE = PIECE_SIZE * 0.4; // how close to snap
    const DAY_LETTER_KEY = "advent_day_4_letter";
    const HIDDEN_LETTER = "V";

    // TRUE bottom-left tile of the full image (row 9, col 0)
    const FIXED_ROW = ROWS - 1;
    const FIXED_COL = 0;

    const boardEl = document.getElementById("board");
    const puzzleAreaEl = document.getElementById("puzzleArea");
    const trayEl = document.getElementById("piecesTray");
    const statusLineEl = document.getElementById("statusLine");
    const alreadyBanner = document.getElementById("alreadyBanner");
    const inspectBtn = document.getElementById("inspectBtn");
    const backOverlay = document.getElementById("puzzleBackOverlay");

    let pieces = []; // {row, col, el, placed, locked}
    let draggingPiece = null;
    let dragOffsetX = 0;
    let dragOffsetY = 0;
    let backRevealed = false;

    // ===== UTIL =====
    function setStatus(msg, tone = "") {
      statusLineEl.textContent = msg;
      if (tone === "good") statusLineEl.className = "status status-good";
      else statusLineEl.className = "status";
    }

    function openModal(id) {
      const modal = document.getElementById(id);
      if (!modal) return;
      modal.classList.add("open");
      modal.setAttribute("aria-hidden", "false");
    }

    function closeModal(id) {
      const modal = document.getElementById(id);
      if (!modal) return;
      modal.classList.remove("open");
      modal.setAttribute("aria-hidden", "true");
    }

    function shuffleArray(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    // ===== LAYOUT HELPERS =====
    function getBoardRect() {
      return boardEl.getBoundingClientRect();
    }

    function getAreaRect() {
      return puzzleAreaEl.getBoundingClientRect();
    }

    function targetPositionForPiece(row, col) {
      const boardRect = getBoardRect();
      const areaRect = getAreaRect();
      const offsetX = boardRect.left - areaRect.left;
      const offsetY = boardRect.top - areaRect.top;

      return {
        x: offsetX + col * PIECE_SIZE,
        y: offsetY + row * PIECE_SIZE
      };
    }

    function pieceCenter(piece) {
      const rect = piece.el.getBoundingClientRect();
      const areaRect = getAreaRect();
      return {
        x: rect.left - areaRect.left + rect.width / 2,
        y: rect.top - areaRect.top + rect.height / 2
      };
    }

    function distance(a, b) {
      const dx = a.x - b.x;
      const dy = a.y - b.y;
      return Math.sqrt(dx * dx + dy * dy);
    }

    // ===== CREATE PIECES =====
    function createPieces() {
      pieces = [];
      boardEl.style.width = `${COLS * PIECE_SIZE}px`;
      boardEl.style.height = `${ROWS * PIECE_SIZE}px`;

      for (let row = 0; row < ROWS; row++) {
        for (let col = 0; col < COLS; col++) {
          const pieceEl = document.createElement("div");
          pieceEl.className = "piece";
          pieceEl.style.backgroundPosition = `-${col * PIECE_SIZE}px -${row * PIECE_SIZE}px`;

          const info = {
            row,
            col,
            el: pieceEl,
            placed: false,
            locked: row === FIXED_ROW && col === FIXED_COL
          };

          pieces.push(info);
        }
      }

      // Place locked bottom-left piece onto the board in its exact corner position
      pieces.forEach((info) => {
        if (info.locked) {
          const pieceEl = info.el;
          puzzleAreaEl.appendChild(pieceEl);
          const pos = targetPositionForPiece(info.row, info.col);
          pieceEl.style.left = `${pos.x}px`;
          pieceEl.style.top = `${pos.y}px`;
          pieceEl.classList.add("locked", "placed");
          info.placed = true;
        }
      });

      // All other pieces go into the tray, but SCRAMBLED
      const trayPieces = shuffleArray(pieces.filter((p) => !p.locked));
      trayPieces.forEach((info) => {
        info.el.classList.add("in-tray");
        info.el.style.position = "static";
        info.el.style.left = "";
        info.el.style.top = "";
        trayEl.appendChild(info.el);
      });
    }

    function resetLoosePiecesToTray() {
      // Send all non-locked, non-placed pieces back to tray in a new random order
      const loose = pieces.filter((p) => !p.locked && !p.placed);
      const shuffled = shuffleArray(loose.slice());

      trayEl.innerHTML = "";
      shuffled.forEach((info) => {
        info.el.classList.add("in-tray");
        info.el.style.position = "static";
        info.el.style.left = "";
        info.el.style.top = "";
        trayEl.appendChild(info.el);
      });

      // Also leave already-placed pieces where they are
      backOverlay.classList.remove("show");
      backRevealed = false;
      inspectBtn.disabled = !allPlaced();
      setStatus("Loose pieces returned to the tray in a new order.", "");
    }

    // ===== DRAGGING =====
    function onPointerDown(e, pieceInfo) {
      if (pieceInfo.locked || pieceInfo.placed || backRevealed) return;

      const pointerX = e.clientX ?? e.touches?.[0]?.clientX;
      const pointerY = e.clientY ?? e.touches?.[0]?.clientY;

      // If currently in the tray, move it into the puzzle area and preserve its on-screen position
      if (pieceInfo.el.parentElement === trayEl) {
        const rectBefore = pieceInfo.el.getBoundingClientRect();
        const areaRect = getAreaRect();

        puzzleAreaEl.appendChild(pieceInfo.el);
        pieceInfo.el.classList.remove("in-tray");
        pieceInfo.el.style.position = "absolute";
        pieceInfo.el.style.left = `${rectBefore.left - areaRect.left}px`;
        pieceInfo.el.style.top = `${rectBefore.top - areaRect.top}px`;
      }

      draggingPiece = pieceInfo;

      const rect = pieceInfo.el.getBoundingClientRect();
      dragOffsetX = pointerX - rect.left;
      dragOffsetY = pointerY - rect.top;

      pieceInfo.el.classList.add("dragging");
      pieceInfo.el.setPointerCapture?.(e.pointerId);

      e.preventDefault();
    }

    function onPointerMove(e) {
      if (!draggingPiece) return;

      const pointerX = e.clientX ?? e.touches?.[0]?.clientX;
      const pointerY = e.clientY ?? e.touches?.[0]?.clientY;

      const areaRect = getAreaRect();

      let x = pointerX - areaRect.left - dragOffsetX;
      let y = pointerY - areaRect.top - dragOffsetY;

      const maxX = areaRect.width - PIECE_SIZE;
      const maxY = areaRect.height - PIECE_SIZE;
      x = Math.max(0, Math.min(maxX, x));
      y = Math.max(0, Math.min(maxY, y));

      draggingPiece.el.style.left = `${x}px`;
      draggingPiece.el.style.top = `${y}px`;
    }

    function onPointerUp() {
      if (!draggingPiece) return;

      const pieceInfo = draggingPiece;
      pieceInfo.el.classList.remove("dragging");
      draggingPiece = null;

      const center = pieceCenter(pieceInfo);
      const targetPos = targetPositionForPiece(pieceInfo.row, pieceInfo.col);
      const targetCenter = {
        x: targetPos.x + PIECE_SIZE / 2,
        y: targetPos.y + PIECE_SIZE / 2
      };

      if (distance(center, targetCenter) <= SNAP_DISTANCE) {
        // snap into place
        pieceInfo.el.style.left = `${targetPos.x}px`;
        pieceInfo.el.style.top = `${targetPos.y}px`;
        pieceInfo.placed = true;
        pieceInfo.el.classList.add("placed");
        checkCompletion();
      }
    }

    function attachDragHandlers() {
      pieces.forEach((p) => {
        p.el.addEventListener("pointerdown", (e) => onPointerDown(e, p));
      });

      window.addEventListener("pointermove", onPointerMove);
      window.addEventListener("pointerup", onPointerUp);
      window.addEventListener("pointercancel", onPointerUp);
    }

    // ===== WIN CONDITION / INSPECT =====
    function allPlaced() {
      return pieces.every((p) => p.placed);
    }

    function checkCompletion() {
      if (allPlaced()) {
        setStatus("Every piece fits. Time to flip it over.", "good");
        inspectBtn.disabled = false;
      } else {
        setStatus("Nice snap! Keep going.", "good");
      }
    }

    function revealBack() {
      if (!allPlaced()) return;

      if (!backRevealed) {
        backRevealed = true;
        backOverlay.classList.add("show");

        setTimeout(() => {
          if (!localStorage.getItem(DAY_LETTER_KEY)) {
            localStorage.setItem(DAY_LETTER_KEY, HIDDEN_LETTER);
          }
          alreadyBanner.style.display = "block";
          openModal("letterModal");
        }, 650);
      } else {
        if (!localStorage.getItem(DAY_LETTER_KEY)) {
          localStorage.setItem(DAY_LETTER_KEY, HIDDEN_LETTER);
        }
        alreadyBanner.style.display = "block";
        openModal("letterModal");
      }
    }

    // ===== INIT =====
    function init() {
      if (localStorage.getItem(DAY_LETTER_KEY)) {
        alreadyBanner.style.display = "block";
      }

      createPieces();
      attachDragHandlers();

      document.getElementById("shuffleBtn").addEventListener("click", () => {
        resetLoosePiecesToTray();
      });

      inspectBtn.addEventListener("click", revealBack);

      document.getElementById("backBtn").addEventListener("click", () => {
        window.location.href = "../../index.html";
      });

      document.getElementById("goHomeFromModal").addEventListener("click", () => {
        window.location.href = "../../index.html";
      });

      document
        .querySelectorAll("[data-close]")
        .forEach((btn) =>
          btn.addEventListener("click", () =>
            closeModal(btn.getAttribute("data-close"))
          )
        );

      document.querySelectorAll(".modal").forEach((modal) => {
        modal.addEventListener("click", (e) => {
          if (e.target === modal) {
            modal.classList.remove("open");
            modal.setAttribute("aria-hidden", "true");
          }
        });
      });

      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape") {
          document
            .querySelectorAll(".modal.open")
            .forEach((m) => m.classList.remove("open"));
        }
      });
    }

    window.addEventListener("load", init);
  </script>
</body>
</html>
